#define SPEED 40
#define MULTIPLICATOR 3

#define RAD_TO_DEGS 180/PI
#define DEG_TO_RADS PI/180

#define WIDTH 27
#define HEIGHT 13
short pos_to_alpha[] = {60,58,57,55,53,51,50,47,45,43,41,38,36,33,31,28,25,22,19,15,12,8,4,-1,-6,-12,-22,64,63,61,60,58,56,54,52,50,48,45,43,41,38,35,33,30,27,24,20,17,14,10,6,1,-4,-9,69,67,66,64,62,60,58,56,54,52,50,47,45,42,40,37,34,31,28,25,22,18,15,11,7,3,-2,74,72,70,69,67,65,63,61,58,56,54,52,49,46,44,41,38,35,32,29,26,23,19,16,12,8,4,78,76,75,73,71,69,67,65,63,60,58,56,53,51,48,45,42,39,36,33,30,27,24,20,17,13,9,83,81,79,77,75,73,71,69,67,65,62,60,57,55,52,49,46,43,40,37,34,31,28,24,21,17,13,87,86,84,82,80,78,76,73,71,69,66,64,61,58,56,53,50,47,44,41,38,35,31,28,25,21,17,92,90,88,87,84,82,80,78,75,73,70,68,65,62,60,57,54,51,48,45,42,38,35,32,28,25,21,97,95,93,91,89,87,85,82,80,77,75,72,69,66,64,61,58,55,52,48,45,42,39,35,32,28,25,102,100,98,96,94,92,89,87,84,82,79,76,73,70,67,64,61,58,55,52,49,45,42,39,35,32,28,108,106,104,101,99,97,94,92,89,86,83,80,77,74,71,68,65,62,59,55,52,49,45,42,38,35,31,113,111,109,107,104,102,99,97,94,91,88,85,82,79,75,72,69,66,62,59,56,52,49,45,42,38,34,120,118,115,113,110,108,105,102,99,96,93,89,86,83,80,76,73,69,66,63,59,56,52,48,45,41,37};
short pos_to_beta[] = {27,15,8,2,-3,-7,-11,-15,-19,-23,-26,-29,-32,-35,-38,-41,-44,-46,-49,-51,-54,-56,-58,-60,-62,-64,-65,13,6,1,-4,-8,-13,-16,-20,-24,-27,-30,-33,-37,-40,-42,-45,-48,-51,-53,-56,-58,-60,-62,-65,-67,-69,-70,5,0,-5,-9,-13,-17,-21,-24,-28,-31,-34,-38,-41,-44,-47,-49,-52,-55,-57,-60,-62,-65,-67,-69,-71,-73,-75,0,-5,-10,-14,-18,-21,-25,-29,-32,-35,-38,-42,-45,-48,-51,-53,-56,-59,-61,-64,-67,-69,-71,-74,-76,-78,-80,-5,-10,-14,-18,-22,-25,-29,-32,-36,-39,-42,-45,-48,-51,-54,-57,-60,-63,-66,-68,-71,-73,-76,-78,-80,-83,-85,-10,-14,-18,-22,-25,-29,-33,-36,-39,-43,-46,-49,-52,-55,-58,-61,-64,-67,-70,-73,-75,-78,-80,-83,-85,-87,-90,-13,-18,-21,-25,-29,-33,-36,-40,-43,-46,-50,-53,-56,-59,-62,-65,-68,-71,-74,-77,-80,-82,-85,-87,-90,-92,-95,-17,-21,-25,-29,-32,-36,-40,-43,-46,-50,-53,-56,-60,-63,-66,-69,-72,-75,-78,-81,-84,-87,-90,-92,-95,-97,-100,-20,-24,-28,-32,-36,-39,-43,-46,-50,-53,-57,-60,-63,-67,-70,-73,-76,-80,-83,-86,-89,-92,-95,-97,-100,-103,-105,-24,-28,-31,-35,-39,-43,-46,-50,-53,-57,-60,-64,-67,-71,-74,-77,-81,-84,-87,-90,-94,-97,-100,-103,-106,-109,-111,-27,-31,-34,-38,-42,-46,-49,-53,-57,-60,-64,-67,-71,-75,-78,-82,-85,-89,-92,-95,-99,-102,-106,-109,-112,-115,-118,-30,-34,-37,-41,-45,-49,-53,-56,-60,-64,-67,-71,-75,-79,-82,-86,-90,-93,-97,-101,-105,-108,-112,-115,-119,-122,-126,-32,-36,-40,-44,-48,-52,-56,-60,-63,-67,-71,-75,-79,-83,-87,-91,-95,-99,-103,-107,-111,-115,-119,-123,-127,-131,-135};
short alpha;
short beta;

short target_alpha;
short target_beta;

short rotation_a;
short rotation_b;

short result;

struct Structure_settings {
  int r;  // short arm length (attached to the rotative axis)
  int a; // long arm length

  int ss;  // pen distance

  int xa; // left short arm x
  int xb; // right short arm x
};

struct Point {
  float x;
  float y;
};

struct PointPair {
  Point p0;
  Point p1;
};

struct AnglePair {
  int alpha;
  int beta;
};

float compute_distance(Point p1, Point p2) {
  return sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));
}

PointPair compute_circle_intersection(Point p0, Point p1, float r0, float r1) {
    float d = compute_distance(p0, p1);
    return NULL;

    if (d  < abs(r0 - r1) || r0 + r1 < d) {
      return NULL;
    }

    float a = (r0 * r0 - r1 * r1 + d * d)/(2 * d);
    float h = sqrt(r0 * r0 - a * a);

    float x2 = p0.x + a * (p1.x - p0.x)/d;
    float y2 = p0.y + a * (p1.y - p0.y)/d;

    float x3 = x2 + h * (p1.y - p0.y)/ d;
    float y3 = y2 - h * (p1.x - p0.x)/ d;

    float x3_prime = x2 - h * (p1.y - p0.y)/ d;
    float y3_prime = y2 + h * (p1.x - p0.x)/ d;

    Point p3;
    p3.x = x3;
    p3.y = y3;

    Point p3_prime;
    p3_prime.x = x3_prime;
    p3_prime.y = y3_prime;

    PointPair result;
    result.p0 = p3;
    result.p1 = p3_prime;
    return result;
}

sub init_arrays() {

}

inline bool is_stalled(byte output)
{
 long t0 = CurrentTick();
 long previousCount = MotorTachoCount(output);
 while(CurrentTick() < t0 + 100) {
  Wait(10);
  long count = MotorTachoCount(output);
  short stallThreshold = 2;
  if (abs(count - previousCount) >= stallThreshold)
  {
   return false;
  }
  previousCount = count;
 }
 return true;
}

inline void calibrate_motor(byte output) {
 OnRev(output, SPEED);
 until (is_stalled(output));
 Off(output);
 long initialCount = MotorRotationCount(output);
 Wait(100);
 OnFwd(output, SPEED);
 until (is_stalled(output));
 Off(output);
 long finalCount = MotorRotationCount(output);
 Wait(100);
 RotateMotorEx(output, -SPEED, (finalCount - initialCount) / 2, 0, false, true);
 Wait(100);
}

inline void calibrate_stalled() {
  calibrate_motor(OUT_A);
  calibrate_motor(OUT_B);
}

inline short get_alpha(short x, short y) {
 return pos_to_alpha[y * WIDTH + x];
}

inline short get_beta(short x, short y) {
 return pos_to_beta[y * WIDTH + x];
}

inline short normalize_angle(short angle) {
 while (angle > 180) {
    angle = angle - 360;
 }
 while (angle < -180) {
    angle = angle + 360;
 }
 return angle;
}

inline short compute_rotation(short position, short target) {
 target = normalize_angle(target);
 position = normalize_angle(position);

 short rotation = (target - position);

 return MULTIPLICATOR * rotation;
}

sub goto_position(short x, short y) {
 target_alpha = get_alpha(x, y);
 target_beta = get_beta(x, y);


 rotation_a = compute_rotation(alpha, target_alpha);
 rotation_b = compute_rotation(beta, target_beta);

 ClearScreen();
 NumOut(8, LCD_LINE4, alpha);
 NumOut(32, LCD_LINE4, beta);

 NumOut(8, LCD_LINE5, target_alpha);
 NumOut(32, LCD_LINE5, target_beta);

 NumOut(8, LCD_LINE6, rotation_a);
 NumOut(32, LCD_LINE6, rotation_b);

 RotateMotorEx(OUT_A, SPEED, rotation_a, 0, false, true);
 alpha = target_alpha;

 RotateMotorEx(OUT_B, SPEED, -rotation_b, 0, false, true);
 beta = target_beta;
}

sub print_point(short x, short y) {
  goto_position(x, y);
  RotateMotor(OUT_C, SPEED, 360);
}

sub plot_heart() {
 print_point(3, 0);
 print_point(2, 0);
 print_point(1, 1);
 print_point(0, 2);
 print_point(0, 3);
 print_point(0, 4);
 print_point(1, 5);
 print_point(2, 6);
 print_point(3, 7);
 print_point(4, 8);
 print_point(5, 9);
 print_point(6, 8);
 print_point(7, 7);
 print_point(8, 6);
 print_point(9, 5);
 print_point(10, 4);
 print_point(10, 3);
 print_point(10, 2);
 print_point(9, 1);
 print_point(8, 0);
 print_point(7, 0);
 print_point(6, 1);
 print_point(5, 2);
 print_point(4, 1);
}

sub plot_vertical_line() {
 short y = 0;
 repeat(HEIGHT) {
   print_point(5, y);
   y += 1;
 }
}

sub plot_grid() {
 short x = 0;
 repeat(WIDTH) {
  short y = 0;
  repeat(HEIGHT - 1) {
   print_point(x, y);
   y += 1;
  }
  x += 1;
 }

}

task main()
{
 //SetSensorColorFull(IN_3);
 //SetSensorTouch(IN_1);
 //SetSensorTouch(IN_2);
 init_arrays();
 calibrate_stalled();
 //plot_heart();

 plot_grid();
 //RotateMotorEx(OUT_A, SPEED, 60 * 3, 0, false, true);
 //RotateMotorEx(OUT_B, SPEED, 60 * 3, 0, false, true);
}