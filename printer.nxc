#define SPEED 40

#define WIDTH 18
#define HEIGHT 18
short pos_to_alpha[] = {270,257,243,230,216,203,190,176,163,149,135,120,105,89,72,52,30,0,277,263,249,235,222,208,195,181,168,154,140,125,111,95,78,60,39,14,283,269,254,240,227,213,199,186,172,159,145,130,116,100,84,67,48,25,289,274,260,246,232,218,204,190,177,163,149,135,120,105,89,73,54,34,295,280,265,251,236,222,208,195,181,167,153,139,125,110,94,78,60,41,302,286,270,255,241,226,212,198,185,171,157,143,128,114,99,83,66,47,308,291,275,260,245,231,216,202,188,174,160,146,132,117,102,87,70,52,314,297,280,264,249,234,220,206,191,177,163,149,135,121,106,90,74,57,320,302,285,269,253,238,223,209,194,180,166,152,138,123,109,94,78,61,326,307,290,273,257,241,226,212,197,183,169,155,140,126,111,96,81,64,333,313,294,277,260,244,229,214,200,185,171,157,143,128,114,99,83,67,339,318,299,281,264,247,232,217,202,187,173,159,145,130,116,101,86,70,346,323,303,284,267,250,234,219,204,189,175,160,146,132,117,103,88,72,352,328,307,288,269,252,236,221,205,191,176,162,147,133,119,104,89,74,359,333,311,291,272,255,238,222,207,192,177,163,148,134,120,105,90,75,367,338,315,294,274,256,240,223,208,193,178,164,149,135,120,106,91,76,375,344,318,296,276,258,241,224,209,193,179,164,150,135,121,106,92,77,383,349,322,299,278,259,242,225,209,194,179,164,150,135,121,107,92,77};
short pos_to_beta[] = {-54,-55,-55,-56,-56,-55,-54,-53,-52,-50,-47,-44,-40,-36,-30,-23,-15,-2,-70,-71,-71,-72,-72,-72,-71,-70,-69,-67,-65,-62,-59,-55,-51,-46,-39,-31,-85,-86,-87,-87,-87,-87,-87,-86,-85,-83,-82,-79,-77,-73,-70,-65,-60,-53,-99,-101,-101,-102,-102,-102,-102,-101,-100,-99,-97,-95,-93,-90,-87,-83,-78,-73,-114,-115,-116,-117,-117,-117,-117,-116,-115,-114,-113,-111,-109,-106,-103,-99,-95,-90,-128,-130,-131,-131,-132,-132,-132,-131,-130,-129,-128,-126,-124,-121,-118,-115,-111,-107,-143,-144,-145,-146,-146,-146,-146,-146,-145,-144,-142,-140,-138,-136,-133,-130,-126,-122,-157,-159,-160,-160,-161,-161,-161,-160,-159,-158,-157,-155,-153,-151,-148,-145,-141,-137,-172,-174,-175,-175,-176,-176,-175,-175,-174,-173,-171,-170,-167,-165,-162,-159,-156,-152,-188,-189,-190,-190,-191,-191,-190,-190,-189,-187,-186,-184,-182,-179,-177,-174,-170,-167,-203,-205,-205,-206,-206,-206,-206,-205,-204,-202,-201,-199,-197,-194,-191,-188,-185,-181,-220,-221,-222,-222,-222,-222,-221,-220,-219,-218,-216,-214,-211,-209,-206,-202,-199,-195,-237,-238,-239,-239,-239,-238,-238,-236,-235,-233,-231,-229,-226,-224,-220,-217,-213,-209,-256,-257,-257,-257,-257,-256,-255,-253,-252,-250,-247,-245,-242,-239,-235,-232,-228,-224,-277,-277,-277,-277,-276,-275,-273,-271,-269,-267,-264,-261,-258,-254,-251,-247,-243,-238,-299,-300,-299,-298,-297,-295,-293,-290,-288,-285,-282,-278,-275,-271,-267,-262,-258,-253,-327,-326,-324,-323,-320,-318,-315,-311,-308,-304,-300,-296,-292,-288,-283,-279,-274,-269,-362,-359,-356,-352,-348,-344,-340,-335,-330,-326,-321,-316,-311,-306,-301,-295,-290,-284};
short alpha;
short beta;

short target_alpha;
short target_beta;

short rotation_a;
short rotation_b;

short result;

float radians_to_degrees = 180/PI;
float degrees_to_radians = PI/180;

float max(float x, float y) {
  if (x >= y) {
    return x;
  }
  return y;
}

float min(float x, float y) {
  if (x <= y) {
    return x;
  }
  return y;
}

float atan2(float y, float x) {
  float t3 = abs(x);
  float t1 = abs(y);
  float t0 = max(t3, t1);
  t1 = min(t3, t1);
  t3 = 1.0 / t0;
  t3 = t1 * t3;

  float t4 = t3 * t3;
  t0 =         - 0.013480470;
  t0 = t0 * t4 + 0.057477314;
  t0 = t0 * t4 - 0.121239071;
  t0 = t0 * t4 + 0.195635925;
  t0 = t0 * t4 - 0.332994597;
  t0 = t0 * t4 + 0.999995630;
  t3 = t0 * t3;

  if (abs(y) > abs(x))
  {
    t3 = 1.570796327 - t3;
  }

  if (x < 0) {
    t3 = 3.141592654 - t3;
  }

  if (y < 0) {
    t3 = -t3;
  }

  return t3;
}

struct StructureSettings {
  int r;  // short arm length (attached to the rotative axis)
  int a; // long arm length

  int s;  // pen distance

  int xa; // left short arm x
  int xb; // right short arm x
};

struct Point {
  float x;
  float y;
};

struct PointPair {
  Point p0;
  Point p1;
};

struct AnglePair {
  int alpha;
  int beta;
};

float compute_distance(Point p1, Point p2) {
  return sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));
}

PointPair compute_circle_intersection(Point p0, Point p1, float r0, float r1, bool & result_set) {
    float d = compute_distance(p0, p1);

    if (d  < abs(r0 - r1) || r0 + r1 < d) {
      result_set = false;
      return NULL;
    }

    float a = (r0 * r0 - r1 * r1 + d * d)/(2 * d);
    float h = sqrt(r0 * r0 - a * a);

    float x2 = p0.x + a * (p1.x - p0.x)/d;
    float y2 = p0.y + a * (p1.y - p0.y)/d;

    float x3 = x2 + h * (p1.y - p0.y)/ d;
    float y3 = y2 - h * (p1.x - p0.x)/ d;

    float x3_prime = x2 - h * (p1.y - p0.y)/ d;
    float y3_prime = y2 + h * (p1.x - p0.x)/ d;

    Point p3;
    p3.x = x3;
    p3.y = y3;

    Point p3_prime;
    p3_prime.x = x3_prime;
    p3_prime.y = y3_prime;

    PointPair result;
    result.p0 = p3;
    result.p1 = p3_prime;
    result_set = true;
    return result;
}

AnglePair get_alpha_beta(Point p, StructureSettings structure_settings, bool & result_set) {
    float r_pen = sqrt(structure_settings.a ^ 2 + structure_settings.s ^ 2);

    Point a;
    a.x = structure_settings.a;
    a.y = 0;

    PointPair intersection1 = compute_circle_intersection(a, p, structure_settings.r, r_pen, result_set);
    if (result_set == false) {
        return NULL;
    }
    Point p1 = intersection1.p0;
    Point p1_prime = intersection1.p1;

    float alpha = atan2(structure_settings.xa - p1.x, p1.y) * radians_to_degrees;
    float alpha_prime = atan2(structure_settings.xa - p1_prime.x, p1_prime.y) * radians_to_degrees;

    float alpha_result;
    Point p1_actual;
    if (p1.x < p1_prime.x) {
        alpha_result = alpha;
        p1_actual.x = p1.x;
        p1_actual.y = p1.y;
    } else {
        alpha_result = alpha_prime;
        p1_actual.x = p1_prime.x;
        p1_actual.y = p1_prime.y;
    }

    PointPair intersection_cross = compute_circle_intersection(p1_actual, p, structure_settings.a, structure_settings.s, result_set);
    if (result_set == false) {
        return NULL;
    }

    Point p_cross = intersection_cross.p0;
    Point p_cross_prime = intersection_cross.p1;

    Point p_cross_actual;
    if ((p_cross.x - p1_actual.x) * (p.y - p_cross.y) - (p_cross.y - p1_actual.y) * (p.x - p_cross.x) > 0) {
        p_cross_actual.x = p_cross.x;
        p_cross_actual.y = p_cross.y;
    } else {
        p_cross_actual.x = p_cross_prime.x;
        p_cross_actual.y = p_cross_prime.y;
    }

    Point b;
    b.x = structure_settings.xb;
    b.y = 0;

    PointPair intersection2 = compute_circle_intersection(b, p_cross_actual, structure_settings.r, structure_settings.a, result_set);
    if (result_set == false) {
        return NULL;
    }

    Point p2 = intersection2.p0;
    Point p2_prime = intersection2.p1;

    float beta = atan2(structure_settings.xb - p2.x, p2.y) * radians_to_degrees;
    float beta_prime = atan2(structure_settings.xb - p2_prime.x, p2_prime.y) * radians_to_degrees;

    float beta_result;
    if (p2.x > p2_prime.x) {
        beta_result = beta;
    } else {
        beta_result = beta_prime;
    }
    AnglePair result;
    result.alpha = alpha_result;
    result.beta = beta_result;

    if (alpha_result < -135 || 135 < alpha_result) {
        result_set = false;
        return NULL;
    }

    if (beta_result < -135 || 135 < beta_result) {
        result_set = false;
        return NULL;
    }
    result_set = true;
    return result;
}

inline bool is_stalled(byte output)
{
 long t0 = CurrentTick();
 long previousCount = MotorTachoCount(output);
 while(CurrentTick() < t0 + 100) {
  Wait(10);
  long count = MotorTachoCount(output);
  short stallThreshold = 2;
  if (abs(count - previousCount) >= stallThreshold)
  {
   return false;
  }
  previousCount = count;
 }
 return true;
}

inline void calibrate_motor(byte output) {
 OnRev(output, SPEED);
 until (is_stalled(output));
 Off(output);
 long initialCount = MotorRotationCount(output);
 Wait(100);
 OnFwd(output, SPEED);
 until (is_stalled(output));
 Off(output);
 long finalCount = MotorRotationCount(output);
 Wait(100);
 RotateMotorEx(output, -SPEED, (finalCount - initialCount) / 2, 0, false, true);
 Wait(100);
}

inline void calibrate_stalled() {
  calibrate_motor(OUT_A);
  calibrate_motor(OUT_B);
}

inline short get_alpha(short x, short y) {
 return pos_to_alpha[y * WIDTH + x];
}

inline short get_beta(short x, short y) {
 return pos_to_beta[y * WIDTH + x];
}

inline short normalize_angle(short angle) {
 while (angle > 180) {
    angle = angle - 360;
 }
 while (angle < -180) {
    angle = angle + 360;
 }
 return angle;
}

inline short compute_rotation(short position, short target) {
 short rotation = (target - position);
 return rotation;
}

sub goto_position(short x, short y) {
 target_alpha = get_alpha(x, y);
 target_beta = get_beta(x, y);


 rotation_a = compute_rotation(alpha, target_alpha);
 rotation_b = compute_rotation(beta, target_beta);

 ClearScreen();
 NumOut(8, LCD_LINE4, alpha);
 NumOut(32, LCD_LINE4, beta);

 NumOut(8, LCD_LINE5, target_alpha);
 NumOut(32, LCD_LINE5, target_beta);

 NumOut(8, LCD_LINE6, rotation_a);
 NumOut(32, LCD_LINE6, rotation_b);

 RotateMotorEx(OUT_A, SPEED, rotation_a, 0, false, true);
 alpha = target_alpha;

 RotateMotorEx(OUT_B, SPEED, -rotation_b, 0, false, true);
 beta = target_beta;
}

sub print_point(short x, short y) {
  goto_position(x, y);
  //RotateMotor(OUT_C, SPEED, 360);
}

sub plot_heart() {
 print_point(3, 0);
 print_point(2, 0);
 print_point(1, 1);
 print_point(0, 2);
 print_point(0, 3);
 print_point(0, 4);
 print_point(1, 5);
 print_point(2, 6);
 print_point(3, 7);
 print_point(4, 8);
 print_point(5, 9);
 print_point(6, 8);
 print_point(7, 7);
 print_point(8, 6);
 print_point(9, 5);
 print_point(10, 4);
 print_point(10, 3);
 print_point(10, 2);
 print_point(9, 1);
 print_point(8, 0);
 print_point(7, 0);
 print_point(6, 1);
 print_point(5, 2);
 print_point(4, 1);
}

sub plot_invader() {
 print_point(0, 4);
 print_point(0, 5);
 print_point(0, 6);

 print_point(1, 3);
 print_point(1, 4);

 print_point(2, 0);
 print_point(2, 3);
 print_point(2, 4);
 print_point(2, 5);
 print_point(2, 6);
 print_point(2, 7);

 print_point(3, 1);
 print_point(3, 2);
 print_point(3, 4);
 print_point(3, 5);
 print_point(3, 7);

 print_point(4, 3);
 print_point(4, 4);
 print_point(4, 5);
 print_point(4, 6);

 print_point(5, 3);
 print_point(5, 4);
 print_point(5, 5);
 print_point(5, 6);

 print_point(6, 1);
 print_point(6, 2);
 print_point(6, 4);
 print_point(6, 5);
 print_point(6, 7);

 print_point(7, 0);
 print_point(7, 3);
 print_point(7, 4);
 print_point(7, 5);
 print_point(7, 6);
 print_point(7, 7);

 print_point(8, 4);
 print_point(8, 5);
 print_point(8, 6);

 print_point(9, 3);
 print_point(9, 4);
}

sub plot_vertical_line() {
 short y = 0;
 repeat(HEIGHT) {
   print_point(5, y);
   y += 1;
 }
}

sub plot_grid() {
 short x = 0;
 repeat(WIDTH) {
  short y = 0;
  repeat(HEIGHT - 1) {
   print_point(x, y);
   y += 1;
  }
  x += 1;
 }

}

task main()
{
 //SetSensorColorFull(IN_3);
 //SetSensorTouch(IN_1);
 //SetSensorTouch(IN_2);
 calibrate_stalled();
 RotateMotor(OUT_C, SPEED, 180);
 plot_heart();
 //plot_invader();
 //plot_grid();
 float f= atan2(1, 0);
}