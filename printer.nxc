#define SPEED 40

#define WIDTH 18
#define HEIGHT 18

int POINTS_PER_LEGO_UNIT = 4;
short alpha;
short beta;

float radians_to_degrees = 180/PI;
float degrees_to_radians = PI/180;

float max(float x, float y) {
  if (x >= y) {
    return x;
  }
  return y;
}

float min(float x, float y) {
  if (x <= y) {
    return x;
  }
  return y;
}

float atan2(float y, float x) {
  float t3 = abs(x);
  float t1 = abs(y);
  float t0 = max(t3, t1);
  t1 = min(t3, t1);
  t3 = 1.0 / t0;
  t3 = t1 * t3;

  float t4 = t3 * t3;
  t0 =         - 0.013480470;
  t0 = t0 * t4 + 0.057477314;
  t0 = t0 * t4 - 0.121239071;
  t0 = t0 * t4 + 0.195635925;
  t0 = t0 * t4 - 0.332994597;
  t0 = t0 * t4 + 0.999995630;
  t3 = t0 * t3;

  if (abs(y) > abs(x))
  {
    t3 = 1.570796327 - t3;
  }

  if (x < 0) {
    t3 = 3.141592654 - t3;
  }

  if (y < 0) {
    t3 = -t3;
  }

  return t3;
}

struct StructureSettings {
  int r;  // short arm length (attached to the rotative axis)
  int a; // long arm length

  int s;  // pen distance

  int xa; // left short arm x
  int xb; // right short arm x

  int gear_ratio;

  int amplitude_angle;
};

struct Point {
  float x;
  float y;
};

struct PointPair {
  Point p0;
  Point p1;
};

struct AnglePair {
  float alpha;
  float beta;
};

struct PrintSettings {
  Point origin;
  int width;
  int height;
  int points_per_lego_unit;
};


float compute_distance(Point p1, Point p2) {
  return sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));
}

int round(float f) {
  int int_part = f;
  float f_int_part = int_part;
  if (f >= 0) {
    if ((f - int_part) >= 0.5) {
      return int_part + 1;
    } else {
      return int_part;
    }
  } else {
    if ((int_part - f) >= 0.5) {
      return int_part - 1;
    } else {
      return int_part;
    }
  }
}

PointPair compute_circle_intersection(Point p0, Point p1, float r0, float r1, bool & result_set) {
    float d = compute_distance(p0, p1);

    if (d  < abs(r0 - r1) || r0 + r1 < d) {
      result_set = false;
      return NULL;
    }

    float a = (r0 * r0 - r1 * r1 + d * d)/(2 * d);
    float h = sqrt(r0 * r0 - a * a);

    float x2 = p0.x + a * (p1.x - p0.x)/d;
    float y2 = p0.y + a * (p1.y - p0.y)/d;

    float x3 = x2 + h * (p1.y - p0.y)/ d;
    float y3 = y2 - h * (p1.x - p0.x)/ d;

    float x3_prime = x2 - h * (p1.y - p0.y)/ d;
    float y3_prime = y2 + h * (p1.x - p0.x)/ d;

    Point p3;
    p3.x = x3;
    p3.y = y3;

    Point p3_prime;
    p3_prime.x = x3_prime;
    p3_prime.y = y3_prime;

    PointPair result;
    result.p0 = p3;
    result.p1 = p3_prime;
    result_set = true;
    return result;
}

AnglePair get_alpha_beta(Point p, StructureSettings structure_settings, bool & result_set) {
    float r_pen = sqrt(structure_settings.a * structure_settings.a + structure_settings.s * structure_settings.s);

    Point a;
    a.x = structure_settings.xa;
    a.y = 0;

    PointPair intersection1 = compute_circle_intersection(a, p, structure_settings.r, r_pen, result_set);
    if (result_set == false) {
        ClearScreen();
        TextOut(8, LCD_LINE4, "Can't compute 1st intersection");
        Wait(1000);
        return NULL;
    }
    Point p1 = intersection1.p0;
    Point p1_prime = intersection1.p1;

    float alpha = atan2(structure_settings.xa - p1.x, p1.y) * radians_to_degrees;
    float alpha_prime = atan2(structure_settings.xa - p1_prime.x, p1_prime.y) * radians_to_degrees;

    float alpha_result;
    Point p1_actual;
    if (p1.x < p1_prime.x) {
        alpha_result = alpha;
        p1_actual.x = p1.x;
        p1_actual.y = p1.y;
    } else {
        alpha_result = alpha_prime;
        p1_actual.x = p1_prime.x;
        p1_actual.y = p1_prime.y;
    }

    PointPair intersection_cross = compute_circle_intersection(p1_actual, p, structure_settings.a, structure_settings.s, result_set);
    if (result_set == false) {
        ClearScreen();
        TextOut(8, LCD_LINE4, "Can't compute 2nd intersection");
        Wait(1000);
        return NULL;
    }

    Point p_cross = intersection_cross.p0;
    Point p_cross_prime = intersection_cross.p1;

    Point p_cross_actual;
    if ((p_cross.x - p1_actual.x) * (p.y - p_cross.y) - (p_cross.y - p1_actual.y) * (p.x - p_cross.x) > 0) {
        p_cross_actual.x = p_cross.x;
        p_cross_actual.y = p_cross.y;
    } else {
        p_cross_actual.x = p_cross_prime.x;
        p_cross_actual.y = p_cross_prime.y;
    }

    Point b;
    b.x = structure_settings.xb;
    b.y = 0;

    PointPair intersection2 = compute_circle_intersection(b, p_cross_actual, structure_settings.r, structure_settings.a, result_set);
    if (result_set == false) {
        ClearScreen();
        TextOut(8, LCD_LINE4, "Can't compute 3rd intersection");
        Wait(1000);
        return NULL;
    }

    Point p2 = intersection2.p0;
    Point p2_prime = intersection2.p1;

    float beta = atan2(structure_settings.xb - p2.x, p2.y) * radians_to_degrees;
    float beta_prime = atan2(structure_settings.xb - p2_prime.x, p2_prime.y) * radians_to_degrees;

    float beta_result;
    if (p2.x > p2_prime.x) {
        beta_result = beta;
    } else {
        beta_result = beta_prime;
    }
    AnglePair result;
    result.alpha = alpha_result;
    result.beta = beta_result;

    int amplitude_angle = structure_settings.amplitude_angle;
    if (alpha_result < -amplitude_angle || amplitude_angle < alpha_result) {
        result_set = false;
        return NULL;
    }

    if (beta_result < -amplitude_angle || amplitude_angle < beta_result) {
        result_set = false;
        return NULL;
    }
    result_set = true;
    return result;
}

inline bool is_stalled(byte output)
{
 long t0 = CurrentTick();
 long previousCount = MotorTachoCount(output);
 while(CurrentTick() < t0 + 100) {
  Wait(10);
  long count = MotorTachoCount(output);
  short stallThreshold = 2;
  if (abs(count - previousCount) >= stallThreshold)
  {
   return false;
  }
  previousCount = count;
 }
 return true;
}

inline void calibrate_motor(byte output) {
 OnRev(output, SPEED);
 until (is_stalled(output));
 Off(output);
 long initialCount = MotorRotationCount(output);
 Wait(100);
 OnFwd(output, SPEED);
 until (is_stalled(output));
 Off(output);
 long finalCount = MotorRotationCount(output);
 Wait(100);
 RotateMotorEx(output, -SPEED, (finalCount - initialCount) / 2, 0, false, true);
 Wait(100);
}

inline void calibrate_stalled() {
  calibrate_motor(OUT_A);
  calibrate_motor(OUT_B);
}

inline short normalize_angle(short angle) {
 while (angle > 180) {
    angle = angle - 360;
 }
 while (angle < -180) {
    angle = angle + 360;
 }
 return angle;
}

inline short compute_rotation(short position, short target) {
 short rotation = (target - position);
 return rotation;
}

PrintSettings get_print_settings() {
 PrintSettings print_settings;
 Point origin;
 origin.x = 4;
 origin.x = -origin.x;
 origin.y = 13;
 print_settings.origin = origin;

 print_settings.width = 27;
 print_settings.height = 13;
 print_settings.points_per_lego_unit = 4;
 return print_settings;
}

StructureSettings get_structure_settings() {
  StructureSettings structure_settings;
  structure_settings.r = 3;  // short arm length (attached to the rotative axis)
  structure_settings.a = 12;  // long arm length
  structure_settings.s = 1;  // pen distance

  structure_settings.xa = -5; //left short arm x
  structure_settings.xb = 5; //right short arm x

  structure_settings.gear_ratio = 3;

  structure_settings.amplitude_angle = 135;
  return structure_settings;
}

void goto_position(float x, float y)
{
  PrintSettings print_settings= get_print_settings();

  //convert to actual position
  x = x/print_settings.points_per_lego_unit;
  y = y/print_settings.points_per_lego_unit;
  y = -y;

  x = x + print_settings.origin.x;
  y = y + print_settings.origin.y;

  Point p;
  p.x = x;
  p.y = y;

  StructureSettings structure_settings = get_structure_settings();

  bool result_set = false;
  //get alpha beta
  AnglePair angle_pair = get_alpha_beta(p, structure_settings, result_set);
  if (!result_set)
  {
    return;
  }
  short target_alpha = round(structure_settings.gear_ratio * angle_pair.alpha);
  short target_beta = round(structure_settings.gear_ratio * angle_pair.beta);

  /*
  ClearScreen();
  NumOut(8, LCD_LINE6, structure_settings.gear_ratio * angle_pair.alpha);
  NumOut(52, LCD_LINE6, structure_settings.gear_ratio * angle_pair.beta);

  NumOut(8, LCD_LINE4, target_alpha);
  NumOut(52, LCD_LINE4, target_beta);
  Wait(2000);
  */

  short rotation_a = compute_rotation(alpha, target_alpha);
  short rotation_b = compute_rotation(beta, target_beta);


  RotateMotorEx(OUT_A, SPEED, rotation_a, 0, false, true);
  alpha = target_alpha;

  RotateMotorEx(OUT_B, SPEED, -rotation_b, 0, false, true);
  beta = target_beta;
}

sub print_point(short x, short y) {
  goto_position(x, y);
  RotateMotor(OUT_C, SPEED, 360);
}

sub plot_rectangle() {
  print_point(0, 0);
  print_point(0, 12);
  print_point(26, 12);
  print_point(26, 0);
}

sub plot_heart() {
 print_point(3, 0);
 print_point(2, 0);
 print_point(1, 1);
 print_point(0, 2);
 print_point(0, 3);
 print_point(0, 4);
 print_point(1, 5);
 print_point(2, 6);
 print_point(3, 7);
 print_point(4, 8);
 print_point(5, 9);
 print_point(6, 8);
 print_point(7, 7);
 print_point(8, 6);
 print_point(9, 5);
 print_point(10, 4);
 print_point(10, 3);
 print_point(10, 2);
 print_point(9, 1);
 print_point(8, 0);
 print_point(7, 0);
 print_point(6, 1);
 print_point(5, 2);
 print_point(4, 1);
}

sub plot_invader() {
 print_point(0, 4);
 print_point(0, 5);
 print_point(0, 6);

 print_point(1, 3);
 print_point(1, 4);

 print_point(2, 0);
 print_point(2, 3);
 print_point(2, 4);
 print_point(2, 5);
 print_point(2, 6);
 print_point(2, 7);

 print_point(3, 1);
 print_point(3, 2);
 print_point(3, 4);
 print_point(3, 5);
 print_point(3, 7);

 print_point(4, 3);
 print_point(4, 4);
 print_point(4, 5);
 print_point(4, 6);

 print_point(5, 3);
 print_point(5, 4);
 print_point(5, 5);
 print_point(5, 6);

 print_point(6, 1);
 print_point(6, 2);
 print_point(6, 4);
 print_point(6, 5);
 print_point(6, 7);

 print_point(7, 0);
 print_point(7, 3);
 print_point(7, 4);
 print_point(7, 5);
 print_point(7, 6);
 print_point(7, 7);

 print_point(8, 4);
 print_point(8, 5);
 print_point(8, 6);

 print_point(9, 3);
 print_point(9, 4);
}

sub plot_vertical_line() {
 short y = 0;
 repeat(HEIGHT) {
   print_point(5, y);
   y += 1;
 }
}

sub plot_grid() {
 short x = 0;
 repeat(WIDTH) {
  short y = 0;
  repeat(HEIGHT - 1) {
   print_point(x, y);
   y += 1;
  }
  x += 1;
 }

}


task main()
{
 //SetSensorColorFull(IN_3);
 //SetSensorTouch(IN_1);
 //SetSensorTouch(IN_2);

 calibrate_stalled();
 //RotateMotor(OUT_C, SPEED, 180);
 //plot_rectangle();
 plot_heart();
 //plot_invader();
 //plot_grid();
 //float f= atan2(1, 0);

}