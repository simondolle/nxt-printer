#ifndef SVG_PARSER_NXC
#define SVG_PARSER_NXC

#include "draw.nxc"

float X_SHIFT = 0;
float Y_SHIFT = 0;

float SCALE_FACTOR = 1;

Point transform_x_y(float x, float y) {
  Point p;
  p.x = SCALE_FACTOR * (x + X_SHIFT);
  p.y = SCALE_FACTOR * (y + Y_SHIFT);
  return p;
}

Point transform_no_shift_x_y(float x, float y) {
  Point p;
  p.x = SCALE_FACTOR * x;
  p.y = SCALE_FACTOR * y;
  return p;
}

string get_token(string& path, int start_position) {
  int token_start = start_position;
  int token_end = start_position;
  while(isspace(StrIndex(path, token_start))) {
    token_start+=1;
  }
  token_end = token_start;
  int len = StrLen(path);
  while(token_end + 1 < len && !isalpha(StrIndex(path, token_end + 1))) {
    token_end += 1;
  }
  return SubStr(path, token_start, token_end - token_start + 1);
}

char get_command(string token) {
  return StrIndex(token, 0);
}

int get_params(string token, float& result[]) {

  int result_index = 0;

  int i = 1;
  int j = 1;
  int len = StrLen(token);
  while(i < len) {
      while((j + 1 < len) && (strcmp(SubStr(token, j + 1, 1), "-") != 0) && (strcmp(SubStr(token, j + 1, 1), ",") != 0)) {
        j += 1;
      }
      //ClearScreen();
      string number = SubStr(token, i, j - i + 1);
      float f = StrToNum(number);
      if(result_index < ArrayLen(result)) {
        result[result_index] = f;
      }
      result_index += 1;
      if(strcmp(SubStr(token, j + 1, 1), ",") == 0) {
        i = j+2;
      }
      else {
        i = j+1;
      }
      j = i;
  }

  return result_index;
}

int get_nb_params(string token) {
  float a[] = {0};
  return get_params(token, a);
}

void parse_path(string path) {
  //ClearScreen();
  //TextOut(8, LCD_LINE4, "-------");
  //TextOut(8, LCD_LINE4, path);
  //Wait(1000);

  int i = 0;
  int len = StrLen(path);
  while(i < len) {
    string token = get_token(path, i);
    i += StrLen(token);
    int nb_params = get_nb_params(token);
    float params[];
    ArrayInit(params, 0, nb_params);
    char command = get_command(token);
    get_params(token, params);

    int param_index = 0;
    while(param_index < nb_params) {
        switch(command) {
            case 'M':
            {
              Point p = transform_x_y(params[param_index], params[param_index + 1]);
              goto_point(p.x, p.y);
              param_index += 2;
              break;
            }
            case 'm':
            {
              Point p = transform_no_shift_x_y(params[param_index], params[param_index + 1]);
              goto_point_relative(p.x, p.y);
              param_index += 2;
              break;
            }
            case 'L':
            {
              Point p = transform_x_y(params[param_index], params[param_index + 1]);
              print_line(p.x, p.y);
              param_index += 2;
              break;
            }
            case 'l':
            {
              Point p = transform_no_shift_x_y(params[param_index], params[param_index + 1]);
              print_line_relative(p.x, p.y);
              param_index += 2;
              break;
            }
            case 'H':
            {
              Point p = transform_x_y(params[param_index], 0);
              horizontal_line_to(p.x);
              param_index += 1;
              break;
            }
            case 'h':
            {
              Point p = transform_no_shift_x_y(params[param_index], 0);
              horizontal_line_to_relative(p.x);
              param_index += 1;
              break;
            }
            case 'V':
            {
              Point p = transform_x_y(0, params[param_index + 0]);
              vertical_line_to(p.y);
              param_index += 1;
              break;
            }
            case 'v':
            {
              Point p = transform_no_shift_x_y(0, params[param_index]);
              vertical_line_to_relative(p.y);
              param_index += 1;
              break;
            }
            case 'z':
            {
              close_path();
              break;
            }
            case 'C':
            {
              Point p1 = transform_x_y(params[param_index    ], params[param_index + 1]);
              Point p2 = transform_x_y(params[param_index + 2], params[param_index + 3]);
              Point p3 = transform_x_y(params[param_index + 4], params[param_index + 5]);
              curve_to(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
              param_index += 6;
              break;
            }
            case 'c':
            {
              Point p1 = transform_no_shift_x_y(params[param_index    ], params[param_index + 1]);
              Point p2 = transform_no_shift_x_y(params[param_index + 2], params[param_index + 3]);
              Point p3 = transform_no_shift_x_y(params[param_index + 4], params[param_index + 5]);
              curve_to_relative(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
              param_index += 6;
              break;
            }
            case 'S':
            {
              Point p2 = transform_x_y(params[param_index   ], params[param_index + 1]);
              Point p3 = transform_x_y(params[param_index + 2], params[param_index + 3]);
              smooth_curve_to(p2.x, p2.y, p3.x, p3.y);
              param_index += 4;
              break;
            }
            case 's':
            {
              Point p2 = transform_no_shift_x_y(params[param_index    ], params[param_index + 1]);
              Point p3 = transform_no_shift_x_y(params[param_index + 2], params[param_index + 3]);
              smooth_curve_to_relative(p2.x, p2.y, p3.x, p3.y);
              param_index += 4;
              break;
            }
            default:
            {
              ClearScreen();
              TextOut(8, LCD_LINE4, "Unknown command");
            }
        }
    }
  }
  pen_up();
}

void reset_min_max_x_y() {
  MIN_X = UNSET;
  MAX_X = UNSET;
  MIN_Y = UNSET;
  MAX_Y = UNSET;
}


bool is_path_start(int i, string& svg, int& start_index, int& end_index, bool debug) {
  int index = i;
  int len = StrLen(svg);


  if (debug) {
    ClearScreen();
    TextOut(8, LCD_LINE4, SubStr(svg, i, 1));
    Wait(1000);
  }

  if (index >= len || StrIndex(svg, index) != ' ') {
    if (debug) {
      ClearScreen();
      TextOut(8, LCD_LINE4, "Space not found");
      Wait(1000);
    }

    return false;
  }
  index += 1;
  if (index >= len) {
    return false;
  }

  if (debug) {
    ClearScreen();
    TextOut(8, LCD_LINE4, "Space found");
    Wait(1000);
  }

  while(StrIndex(svg, index) == ' ') {
    index += 1;
    if (index >= len) {
      return false;
    }
  }

  if(StrIndex(svg, index) != 'd') {
    return false;
  }

  if (debug) {
    ClearScreen();
    TextOut(8, LCD_LINE4, "d found");
    Wait(1000);
  }

  index += 1;
  if (index >= len) {
      return false;
  }
  while(StrIndex(svg, index) == ' ') {
    index += 1;
    if (index >= len) {
      return false;
    }
  }

  if (debug) {
    ClearScreen();
    TextOut(8, LCD_LINE4, "spaces found");
    Wait(1000);
  }

  if(StrIndex(svg, index) != '=') {
    return false;
  }

  if (debug) {
    ClearScreen();
    TextOut(8, LCD_LINE4, "= found");
    Wait(1000);
  }

  index += 1;
  if (index >= len) {
      return false;
  }
  while(StrIndex(svg, index) == ' ') {
    index += 1;
    if (index >= len) {
      return false;
    }
  }
  if (debug) {
    ClearScreen();
    TextOut(8, LCD_LINE4, "spaces found");
    Wait(1000);
  }


  if(StrIndex(svg, index) != ''' && StrIndex(svg, index) != '"') {
    if (debug) {
      ClearScreen();
      TextOut(8, LCD_LINE4, SubStr(svg, index, 1));
      TextOut(8, LCD_LINE3, "-----------");
      Wait(1000);

      ClearScreen();
      TextOut(8, LCD_LINE4, "delimiter not found");
      Wait(1000);
    }

    return false;
  }
  char c = StrIndex(svg, index);

  if (debug) {
    ClearScreen();
    TextOut(8, LCD_LINE4, "Delimiter found");
    Wait(1000);
  }

  index += 1;
  start_index = index;
  if (index >= len) {
      return false;
  }

  index += 1;
  if (index >= len) {
      return false;
  }

  while(StrIndex(svg, index) != c) {
    index += 1;
    if (index >= len) {
      return false;
    }
  }

  if (debug) {
    ClearScreen();
    TextOut(8, LCD_LINE4, "Matching delimiter found");
    Wait(1000);
  }

  end_index = index - 1;
  return true;
}

void parse_svg(string& svg) {
 int i = 0;
 bool path_found = false;
 while(i < StrLen(svg)) {
   int start_position;
   int end_position;
   bool debug = false;

   //ClearScreen();
   //NumOut(8, LCD_LINE4, i);
   //Wait(10);

   //if (i == 1186 || i == 1187 || i == 1188) {
   //  debug = true;
   //  ClearScreen();
   //  TextOut(8, LCD_LINE4, "Debug");
   //  Wait(1000);
   //}


   bool is_start = is_path_start(i, svg, start_position, end_position, debug);
   if (is_start) {
     //ClearScreen();
     //TextOut(8, LCD_LINE4, "Path found");
     //Wait(1000);

     //ClearScreen();
     //NumOut(8, LCD_LINE4, start_position);
     //NumOut(32, LCD_LINE4, end_position);
     //Wait(1000);

     path_found = true;
     string path = SubStr(svg, start_position, end_position - start_position + 1);
     parse_path(path);
     i = end_position + 1;
   } else {
     i += 1;
   }
 }

 if (!path_found) {
   ClearScreen();
   TextOut(8, LCD_LINE4, "Path not found");
   Wait(1000);
 }

}

void set_scaling_parameters(string& svg) {
  reset_min_max_x_y();
  SIMULATION = true;

  parse_svg(svg);

  X_SHIFT = -MIN_X;
  Y_SHIFT = -MIN_Y;

  PrintSettings print_settings = get_print_settings();

  float scale_x = print_settings.width * print_settings.points_per_lego_unit /(MAX_X - MIN_X);
  float scale_y = print_settings.height * print_settings.points_per_lego_unit /(MAX_Y - MIN_Y);

  SCALE_FACTOR = min(scale_x, scale_y);

  reset_min_max_x_y();
  SIMULATION = false;
}


void draw_svg(string& svg) {
  //ClearScreen();
  //TextOut(8, LCD_LINE4, "-----");
  set_scaling_parameters(svg);
  parse_svg(svg);
}

#endif
